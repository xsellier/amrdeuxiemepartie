% -*- mode: latex; coding: latin-1-unix -*- %

\section{Prototype}

Voici l'algo récursif auquel j'ai pens\'e. La syntaxe n'est pas correcte.

Voilà notre algorithme r\'ecursif pour la couverture de sommet :

\begin{verbatim}

map <key, iterator> graph;

int[] couverture;

int nb_sommet = 0;

function int algo1(var noeud:entiers){
  int couvert = 1;
  Pour chaque fils du sommet  noeud  faire
     couvert *= algo1(nom_du_fils);
  FindePour
  Si couvert == 1 faire
     couvert = 2;
  FindeSi
  Si couvert > 2 faire
     couvert = 1;
     couverture[nb_sommet]=noeud;
     nb_sommet++;
  FindeSi
  Si couvert == 0 faire
     couvert = 1;
     couverture[nb_sommet]=noeud;
     nb_sommet++;
  FindeSi
  Si nb_fils_du_noeud == O;
    couvert = 0;
  FindeSi
  retourner couvert;
}
\end{verbatim}

\bigskip
Exemple de fonctionnement de notre méthode sur notre graphe exemple.

Prenons cet arbre :\\
0-1-3\\
|\\
2-4-7\\
|\\
5\\
|\\
6

\newpage
Dans notre variable graphe on aura donc :

[0] -> [ 1 - 2 ]

[1] -> [ 3 ]

[2] -> [ 4 - 5]

[3] -> null

[4] -> [7]

[5] -> [6]

[6] -> null

[7] -> null

\bigskip
Déroulement de notre algorithme :

\begin{verbatim}

algo1(0);
|- algo1(1);
|  |- algo1(3);
|  |  |- retourne couvert = 0;
|  |- couvert = 0;
|  |- couvert = 1;
|  |- couverture[0] = 1:
|  |- nb_sommet = 1;
|  |- retourne couvert = 1;
|- couvert = 1;
|- algo1(2);
|  |- algo(4);
|  |  |- algo(7);
|  |  |  |- retourne couvert = 0;
|  |  |- couvert = 0;
|  |  |- couvert = 1;
|  |  |- couverture[1] = 4;
|  |  |- nb_sommet = 2;
|  |  |- retourne couvert = 1;
|  |- algo(5);
|  |  |- algo(6);
|  |  |  |- retourne couvert = 0;
|  |  |- couvert = 0;
|  |  |- couvert = 1;
|  |  |- couverture[2] = 5;
|  |  |- nb_sommet = 3;
|  |  |- retourne couvert = 1;
|  |- couvert = 1;
|  |- couvert = 2;
|  |- retourne couvert = 2;
|- couvert = 2;
|- couvert = 1;
|- couverture[3] = 0;
|- nb_sommet = 4;
|- retourne couvert = 1;

\end{verbatim}

Voici un second algo pour la couverture d'ar\^ete cette fois ci :

\begin{verbatim}

map <key, iterator> graph;

int[] couverture;

int nb_sommet = 0;

function int algo2(var noeud:entiers){
  int couvert = 1;
  Pour chaque fils du sommet  noeud  faire
     couvert *= algo2(nom_du_fils);
  FindePour
  Si couvert == 1 faire
     couvert = 2;
  Sinon 
     Si couvert >= 2 faire
       couvert = 1;
       couverture[nb_sommet]=noeud;
       nb_sommet++;
     FindeSi
  FindeSi
  Si couvert == 0 faire
     couvert = 1;
     couverture[nb_sommet]=noeud;
     nb_sommet++;
  FindeSi
  Si nb_fils_du_noeud == O;
    couvert = 0;
  FindeSi
  retourner couvert;
}
\end{verbatim}

P.S : je n'\'etais pas à poil devant mon ordi lorsque j'ai pens\'e a cette petite rectification de l'algo (m\^eme si l'heure était avanc\'ee dans la nuit).
